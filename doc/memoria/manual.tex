% Este archivo es parte de la memoria de libWiiEsp, protegida bajo la 
% licencia GFDL. Puede encontrar una copia de la licencia en el archivo fdl-1.3.tex

% Fuente tomada de la plantilla LaTeX para la realización de Proyectos Final 
% de Carrera de Pablo Recio Quijano.

% Copyright (C) 2009 Pablo Recio Quijano
% Copyright (C) 2011 Ezequiel Vázquez de la Calle

% -*-manual.tex-*-

\section{Instalación del entorno de desarrollo}

Esta sección del manual detalla paso a paso la instalación de estas dependencias en un sistema \emph{GNU/Linux} de 32 bits, siendo el proceso prácticamente el mismo para sistemas de 64 bits (únicamente cambia la versión de las herramientas base, que deberá ser en este caso la adecuada para 64 bits). Para sistemas Windows también es posible desarrollar con \emph{LibWiiEsp}, pero este manual no cubre este tipo de arquitecturas. \\

En primer lugar, hay que crear una carpeta accesible para todos los usuarios del sistema, donde irán emplazadas las herramientas y dependencias de \emph{LibWiiEsp}. Lo ideal es crear un directorio dentro de \texttt{/opt} y otorgarle a éste los permisos necesarios, pero es posible realizar la instalación en nuestro directorio \texttt{/home}, de tal manera que sólo nuestro usuario pueda acceder a estas herramientas. \\

Suponiendo que se escoge la primera opción, se crea el directorio en \texttt{/opt} y se le asignan permisos para que todos los usuarios del sistema puedan hacer uso de lo que en él se almacene:

\begin{lstlisting}[style=consola]
  sudo mkdir /opt/devkitpro
  sudo chmod 777 /opt/devkitpro
\end{lstlisting}

A continuación, hay que descargar las herramientas que sirven de base para \emph{LibWiiEsp}, que son el conjunto de compiladores, bibliotecas y binarios \emph{DevKitPPC}, y la biblioteca de bajo nivel \emph{libOgc}, en su versión 1.8.4, junto con la modificación de \emph{libFat} 1.0.7 compatible con ella. Ambos recursos se encuentran disponibles en la forja del proyecto, en el paquete \emph{Dependencias}. Se deben descargar en el directorio que acabamos de crear:

\begin{lstlisting}[style=consola]
  cd /opt/devkitpro
  wget http://forja.rediris.es/frs/download.php/2316/devkitPPC_r21-i686-linux.tar.bz2
  wget http://forja.rediris.es/frs/download.php/2315/libogc-1.8.4-and-libfat-1.0.7.tar.gz
\end{lstlisting}

El siguiente paso es descomprimir ambos ficheros y, si no queremos tener ocupado espacio innecesariamente, eliminarlos. Las instrucciones para ejecutar estas acciones son:

\begin{lstlisting}[style=consola]
  tar -xvjf devkitPPC_r21-i686-linux.tar.bz2
  tar -xvzf libogc-1.8.4-and-libfat-1.0.7.tar.gz
  rm devkitPPC_r21-i686-linux.tar.bz2 libogc-1.8.4-and-libfat-1.0.7.tar.gz
\end{lstlisting}

Después de esto, es necesario establecer algunas variables de entorno para que el sistema sepa dónde localizar estas herramientas que acabamos de instalar. Las dos primeras consisten en la ruta hasta el directorio base \emph{devkitpro}, y hasta el directorio donde se encuentran las herramientas como tal, concretamente \emph{devkitpro/devkitPPC}. La tercera variable de entorno indica la dirección IP de nuestra Nintendo Wii dentro de la red local, dato necesario para ejecutar correctamente las aplicaciones que se desarrollen sin que haga falta copiar el ejecutable en la tarjeta SD de la consola cada vez que se genere uno nuevo. \\

Para establecer estas variables de entorno, basta con editar el archivo de configuración \emph{~/.bashrc} del usuario con el que vayamos a desarrollar utilizando \emph{LibWiiEsp}. Si por alguna causa fuera necesario que todos los usuarios del sistema tengan que usar estas herramientas, el archivo de configuración a editar sería \emph{/etc/bashrc}, o su equivalente en el sistema (por ejemplo, para una distribución \emph{Ubuntu 10.10} de 32 bits, el archivo es \emph{/etc/bash.bashrc}).

Suponiendo que sólo nuestro usuario va a desarrollar utilizando \emph{LibWiiEsp}, las instrucciones para establecer estas variables de entorno serían:

\begin{lstlisting}[style=consola]
  echo export DEVKITPRO=/opt/devkitpro >> ~/.bashrc
  echo export DEVKITPPC=$DEVKITPRO/devkitPPC >> ~/.bashrc
  echo export WIILOAD=tcp:192.168.X.X >> ~/.bashrc
\end{lstlisting}

Un detalle, en estas instrucciones, \emph{192.168.X.X} se debe sustituir por la dirección IP que tiene asignada la consola Nintendo Wii en la red local.

A continuación, podemos recargar el fichero de configuración \emph{~/.bashrc} para tener listas las variables de entorno mediante la orden:

\begin{lstlisting}[style=consola]
  source ~/.bashrc
\end{lstlisting}

Llegados a este punto, el último paso para que el entorno de desarrollo funcione correctamente con \emph{LibWiiEsp} es instalar la biblioteca propiamente dicha. Existen dos maneras de realizar esto, o bien podemos descargar la versión estable publicada en la forja, o también compilando el código disponible desde ésta. Para el primer caso, basta con descargar el paquete comprimido desde la página principal de la Forja del proyecto \cite{website:forja}, copiarlo al directorio \emph{/opt/devkitpro}, y descomprimirlo allí. \\

Para compilar la biblioteca a partir de los fuentes, debemos ejecutar las siguientes líneas, siempre que se hayan instalado previamente las dependencias:

\begin{lstlisting}[style=consola]
  svn co https://forja.rediris.es/svn/libwiiesp/trunk libwiiesp
  cd libwiiesp
  make install
\end{lstlisting}

Y después de la instalación de la biblioteca, ya tenemos preparado nuestro sistema para comenzar con el desarrollo de videojuegos en dos dimensiones para Nintendo Wii.

\section{Estructura de un proyecto con \emph{LibWiiEsp}}

Una vez instalado correctamente el entorno de desarrollo para utilizar \emph{LibWiiEsp}, el siguiente paso es crear la estructura de archivos y directorios necesarios para trabajar con un nuevo proyecto para Nintendo Wii. Por supuesto, queda en manos del programador la decisión final sobre esta estructura de directorios, pero, debido a todo lo que hay que tener en cuenta a la hora de desarrollar con \emph{LibWiiEsp} (sobretodo, en lo referente a la compilación y enlazado de los archivos que componen un proyecto), voy a presentar en esta sección un ejemplo de proyecto vacío que quedaría listo para comenzar el desarrollo. Además de tratar la estructura de directorios, también mostraré y explicaré el código de un archivo \emph{makefile} que pueda trabajar con esta organización para el proyecto.

\subsection{Estructura de directorios}

En primer lugar, hay que crear un directorio base donde almacenar todo lo relativo a nuestro proyecto. La localización de este directorio en el sistema es indiferente, de tal manera que, para el ejemplo, lo haremos en nuestro directorio \emph{/home} con las instrucciones:

\begin{lstlisting}[style=consola]
  mkdir ~/juego
  cd ~/juego
\end{lstlisting}

Una vez dentro, la siguiente estructura de directorios sería más que suficiente para albergar todos los componentes del proyecto:

\begin{itemize}
\item \emph{doc}: Documentación del proyecto.
\item \emph{lib}: Bibliotecas externas que se vayan a utilizar en el proyecto. Aquí se debe guardar cada biblioteca en un directorio separado. En cada directorio debe existir un archivo \emph{makefile} el cual compile la biblioteca, y genere un archivo de enlazado estático \emph{.a}, además los archivos de cabecera de la biblioteca externa tienen que estar justo bajo este directorio principal de la biblioteca externa.
\item \emph{media}: En este directorio se colocarán todos los archivos que contengan recursos multimedia que vayan a ser empleados en el proyecto. De momento, sólo están soportados imágenes \emph{bitmap} de 24 bits de color directo, fuentes de texto soportadas por \emph{FreeType2}, efectos de sonido en formato \emph{PCM}, y pistas de música \emph{MP3}.
\item \emph{src}: Aquí van los archivos fuente del proyecto.
\item \emph{xml}: Archivos de datos del proyecto. Como mínimo, aquí se encontrarán el archivo que describe los recursos multimedia que se cargarán en la galería de medias, el archivo del soporte de internacionalización, y el archivo de configuración del programa.
\end{itemize}

\subsection{El archivo \emph{makefile}}

La estructura de directorios, y los detalles que la acompañan (como las restricciones de estructuración a la hora de utilizar bibliotecas externas en el proyecto), se han definido así para trabajar con un archivo de compilación \emph{makefile} concreto. \\

Este archivo de compilación implica una serie de modificaciones considerables en comparación con uno que genere un ejecutable para PC en entornos \emph{GNU/Linux}, por lo que va a detallarse su funcionamiento sección a sección. El objetivo de este \emph{makefile} es generar un ejecutable con extensión \emph{.dol}, que puede lanzarse en una videoconsola Nintendo Wii. A continuación, se muestra un sencillo ejemplo de \emph{makefile} compatible con la estructura de directorios planteada en el punto anterior:

\lstinputlisting[style=makefile]{make_ejemplo}

En el primer bloque que aparece en el ejemplo, se definen una serie de variables que indican los directorios que forman parte del proyecto. \emph{LOCALLIBS} debe recoger los nombres, separados por un espacio, de los directorios principales de cada biblioteca externa que se vaya a emplear en la compilación. La variable \emph{PROJECT} indica el nombre completo del proyecto, y \emph{TARGET} el nombre, sin extensión, del ejecutable que se generará. Para que el programa pueda ser ejecutado con \emph{Homebrew Channel}, se recomienda que se nombre \emph{boot}. Por último, \emph{BUILD} indica el directorio que se creará cuando se ordene la compilación del proyecto para almacenar todos los ficheros objeto del proyecto, \emph{SOURCE} es el directorio donde están todos los archivos fuente, y \emph{DEPSDIR} es donde se generarán los archivos que indican las dependencias entre módulos del sistema, que debe ser el mismo directorio que \emph{BUILD}. \\

A continuación, se deben importar las reglas de compilación para Nintendo Wii, tanto las necesarias para utilizar las herramientas de \emph{DevKitPPC}, como las propias de \emph{LibWiiEsp}. Para ello, antes hay que limpiar las reglas implícitas existentes, lo cual se consigue con la instrucción \emph{.SUFFIXES:}. \\

El bloque de tres instrucciones que viene a continuación se encarga de almacenar en variables una lista de todos los archivos \emph{.cpp} que se encuentran en el directorio de fuentes, y otra lista con la ruta absoluta de los ficheros objeto que se generarán al compilar (es decir, archivos con extensión \emph{.o} en la carpeta indicada por la variable \emph{BUILD}). \\

El cuarto bloque de instrucciones recoge los directorios donde se encuentran los archivos de cabeceras externas (los almacena en la variable \emph{INCLUDE}), los directorios en los cuales hay que buscar las bibliotecas de enlazado estático (guardados en la variable \emph{LIBPATHS}), establece el \emph{VPATH}, crea la lista de bibliotecas a enlazar estáticamente (tomando la variable \emph{LIBWIIESP\_LIBS} para contar con todo lo que necesita un ejecutable generado con \emph{LibWiiEsp}, pero se le debe añadir además lo necesario para enlazar también las bibliotecas externas), y por último, indica la ruta absoluta hasta el ejecutable sin extensión y define el enlazador que se utilizará. \\

El bloque siguiente establece los \emph{flags} de compilación necesarios para generar un ejecutable de extensión \emph{.elf}, que posteriormente se transformará a otro con extensión \emph{.dol}. Y justo después comienzan los objetivos del \emph{makefile}, que se describen a continuación:

\begin{itemize}
\item \emph{all}: Crea un ejecutable \emph{.dol} a partir del código fuente que se encuentre en el directorio indicado en la variable \emph{SOURCE}. Es el objetivo por defecto al ejecutar \emph{make}.
\item \emph{\$(BUILD)}: Crea el directorio donde se crearán todos los ficheros objetos del proyecto.
\item \emph{libs} y \emph{\$(LOCALLIBS)}: Se encargan de compilar las bibliotecas externas, de empaquetarlas en ficheros de enlace estático y mover éstos al directorio de los ficheros objeto.
\item \emph{\$(CURDIR)/\$(BUILD)/\%.o}: Genera un fichero objeto en el directorio \emph{\$(BUILD)} por cada módulo que se encuentre en el directorio de los ficheros fuentes.
\item \emph{listo}: Objetivo que limpia un archivo de extensión \emph{.elf.map}.
\item \emph{run}: Lanza la utilidad \emph{wiiload} para enviar el ejecutable a la Nintendo Wii. Ésta debe tener abierto el \emph{Homebrew Channel} y estar conectada a la red local con la misma dirección IP que se indicó en la variable de entorno \emph{WIILOAD}, de otro modo no ejecutará el programa.
\item \emph{clean}: Objetivo que limpia de archivos temporales el proyecto. Elimina la carpeta donde se almacenan los ficheros objeto, y ejecuta también los objetivos \emph{clean} de cada biblioteca externa.
\end{itemize}

La última parte de este ejemplo se encarga de comprobar que se cumplan las dependencias de los módulos a compilar, de generar un ejecutable \emph{.elf} a partir de los módulos objeto del proyecto, y en último lugar, de crear el ejecutable definitivo \emph{.dol} a partir del archivo \emph{.elf}.

\subsection{Ejecución del programa}

Una vez generado nuestro programa, existen dos maneras de ejecutarlo en la videoconsola. La primera, ya descrita, es lanzarlo a través del objetivo \emph{make run}, para lo cual necesitamos tener correctamente conectada la Nintendo Wii a la red local, y \emph{wiiload} bien configurado con la IP de la consola. \\

La otra manera de hacerlo, que es la necesaria para poder distribuir el programa, es guardar el ejecutable en un directorio de la tarjeta SD de la consola, cuya ruta debe ser \emph{/apps/XXX/boot.dol}, donde XXX es el nombre unix de nuestra aplicación (importante que no contenga espacios). Nótese que tanto el nombre \emph{boot.dol} como el hecho de que el directorio que lo contiene esté dentro del directorio \emph{/apps} es obligatorio. \\

Debido a las características de \emph{Homebrew Channel}, podemos acompañar nuestro ejecutable con una imagen que servirá de icono para la aplicación (debe tener formato PNG, llamarse \emph{icon.png}, y tener un tamaño de 128 píxeles de ancho y 48 de alto), y un fichero XML con la información que deseemos aportar sobre el programa (debe ser un XML con un formato concreto, llamado \emph{meta.xml}). Ambos ficheros, la imagen y el archivo de datos, deben ir en el mismo directorio que el ejecutable. \\

Una referencia sobre los nodos del fichero de datos \emph{meta.xml} que acompaña a una aplicación se puede encontrar a continuación:

\begin{lstlisting}[style=XML]
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<app version="1">
  <name>El nombre de la aplicacion</name>
  <coder>Autor o autores del codigo de la aplicacion.</coder>
  <version>La version de la aplicacion.</version>
  <release_date>Dia de lanzamiento. Formato: AAAAMMDD</release_date>
  <short_description>Comentario que se muestra en el menu principal. No se recomienda que sea mayor de 30 caracteres</short_description>
  <long_description>Descripcion detallada del programa</long_description>
</app>
\end{lstlisting}

\section{Consideraciones sobre programar con \emph{LibWiiEsp}}

A la hora de programar para una plataforma cerrada como es Nintendo Wii, hay que tener una serie de aspectos en cuenta, debido a la arquitectura concreta que tiene el hardware de la consola. Es muy importante tener en cuenta estos detalles, ya que en caso contrario se pueden producir errores o comportamientos inesperados, como texturas que se pisan entre sí en la memoria principal, o excepciones propias del sistema. \\

A continuación se describen todos esos pequeños detalles a tener en cuenta, que si bien sólo suponen un cambio en algunos hábitos a la hora de programar, nos aseguran que todo irá bien (al menos, en lo que al funcionamiento del hardware se refiere).

\subsection{Big Endian}

Lo primero que hay que tener en cuenta es que la representación de los datos en la consola Nintendo Wii se realiza con \emph{Big Endian}, al contrario que las plataformas Intel (la arquitectura, no la marca del procesador), que utilizan \emph{Little Endian} para almacenar la información. Cuando un dato ocupa más de un byte, se puede organizar de mayor a menor peso (esto sería \emph{Big Endian}), o bien de menor a mayor peso (que es la organización en \emph{Little Endian}). \\

Un ejemplo muy claro es la representación del \emph{número mágico} que emplean los archivos de imágenes formadas por mapas de bits (también conocidos como \emph{bitmaps}). Este número es, en su representación decimal, 19778. Si esta cifra la representamos en sistema hexadecimal con \emph{Little Endian} el resultado sería 0x4D42; sin embargo, en un sistema que utilice \emph{Big Endian}, esta cifra se representaría como el hexadecimal 0x424D en la memoria principal. \\

Así pues, como consecuencia de esto, siempre que queramos cargar un archivo binario (una imagen, una pista de música, etc.) en la consola Nintendo Wii, tenemos dos opciones: o bien modificamos la representación del archivo en la plataforma de origen (que normalmente será un ordenador con arquitectura Intel) para que el recurso esté ya representado como \emph{Big Endian}, o podemos utilizar las funciones del espacio de nombres \emph{endian} que se proporcionan en el archivo de cabecera \emph{util.h} de \emph{LibWiiEsp}. Este espacio de nombre aporta las siguientes dos funciones, que se encargan de transformar variables de 16 o 32 bits entre \emph{Little Endian} y \emph{Big Endian} (soportan ambas transformaciones):

\begin{lstlisting}[style=C++]
u16 inline swap16(u16 a) {
  return ((a<<8) | (a>>8));
}

u32 inline swap32(u32 a) {
  return ((a)<<24|(((a)<<8) & 0x00FF0000)|(((a)>>8) & 0x0000FF00)|(a)>>24);
}
\end{lstlisting}

Así pues, únicamente utilizando estas dos funciones con cada dos o cuatro bytes cuando queramos cargar un recurso desde la tarjeta SD podremos evitar los problemas derivados de los distintos sistemas de representación. Para un ejemplo práctico sobre el uso de estas dos funciones, ver el código fuente de la clase Imagen de \emph{LibWiiEsp}.

\subsection{Los tipos de datos}

A la hora de programar para Nintendo Wii se utilizan siempre estos tipos de datos:

\begin{table}[H]
  \label{tiposdatos}
  \begin{center}
  \begin{tabular}{| c | c | c |}
    \hline
    Tipo de dato & Descripción & Rango \\ \hline
    u8 & Entero de 8 bits sin signo & 0 a 255 \\ \hline
    s8 & Entero de 8 bits con signo & -127 a 128 \\ \hline
    u16 & Entero de 16 bits sin signo & rango 0 a 65535 \\ \hline
    s16 & Entero de 16 bits con signo & -32768 a 32767 \\ \hline
    u32 & Entero de 32 bits sin signo & 0 a 0xffffffff \\ \hline
    s32 & Entero de 32 bits con signo & -0x80000000 a 0x7fffffff \\ \hline
    u64 & Entero de 64 bits sin signo & 0 a 0xffffffffffffffff \\ \hline
    s64 & Entero de 64 bits con signo & -0x8000000000000000 a 0x7fffffffffffffff  \\ \hline
    f32 & Flotante de 32 bits & - \\ \hline
    f64 & Flotante de 64 bits & - \\ \hline
  \end{tabular}
  \end{center}
  \caption{Tipos de datos que se deben emplear al programar para Wii}
\end{table}

Todos los tipos de datos disponibles se encuentran en \emph{/opt/devkitpro/libogc/include/gctypes.h}.

\subsection{La alineación de los datos}

Otro detalle importante que se debe contemplar a la hora de programar para Nintendo Wii es que el procesador de la consola necesita alinear los datos conforme a su tamaño. Es decir, si vamos a trabajar con un entero de 32 bits (4 bytes), sólo se pueden almacenar en posiciones de memoria múltiplos de cuatro: 0, 4, 8, 12\ldots Lo mismo ocurre con variables de 16 o 64 bits. \\

Para ilustrar el comportamiento del procesador respecto a la alineación de los datos, podemos considerar el siguiente ejemplo:

\begin{lstlisting}[style=C++]
struct ejemplo {
  u8 entero;
  u32 otro;
}
\end{lstlisting}

La estructura \emph{ejemplo} no se representará igual compilando en una plataforma Intel que en la Wii, ya que en la primera, \emph{entero} se situará en la posición 0 de la memoria, y \emph{otro} ocupará de la posición 1 hasta la 5. Sin embargo, en nuestra consola \emph{entero} ocupará el mismo lugar, la posición 0, pero la variable \emph{otro} necesitará estar alineada a su tamaño, es decir, ocupará las posiciones 4 a 7 de la memoria, y las posiciones entre \emph{entero} y \emph{otro} se rellenarán con ceros para asegurar que el entero de 32 bits está alineado. \\

Esto revierte tanto en la cantidad de memoria ocupada, como en el hecho de que si el procesador encontrara un dato desalineado e intentara leerlo, se produciría un error en el sistema. \\

Para solventar este inconveniente, se debe jugar inteligentemente con las declaraciones de las variables, de tal manera que se organicen los datos de forma alineada.

\subsection{Alineación de datos que usan DMA}

Este es otro caso en el que influye la necesidad de alinear los datos con los que se trabaja. El procesador de la Nintendo Wii trabaja con datos cacheados, pero no así los periféricos (la tarjeta SD, los dispositivos USB o el lector DVD). Además, estos periféricos trabajan con una alineación fija de 32 bytes, y si no se contempla este detalle, se pueden producir errores de \emph{machacamiento} de datos al realizar dos lecturas consecutivas desde periféricos. \\

Además, cuando leemos un dato desde un periférico, se corre el riesgo de machacar el contenido de la caché del procesador, por lo que es imprescindible volcar explícitamente los datos leídos en la memoria, es decir, asegurar de que la lectura se ha realizado completamente antes de realizar cualquier otra acción. \\

Es muy sencillo evitar esta situación, y es preparando la memoria en la que se almacenarán los datos leídos desde el periférico, de tal manera que esté alineada a 32 bytes y su tamaño sea múltiplo de 32. Para ilustrar cómo hacer esto, se muestra un ejemplo a continuación:

\begin{lstlisting}[style=C++]
  // Abrimos el archivo mediante un flujo
  ifstream archivo;
  archivo.open("SD:/apps/wiipang/media/sonido.pcm", ios::binary);

  // Obtener el tamano del sonido
  archivo.seekg(0, ios::end);
  u16 size = archivo.tellg();
  archivo.seekg(0, ios::beg);

  // Calcular el relleno que hay que aplicar a la memoria reservada
  // para que su tamano sea multiplo de 32
  u8 relleno = (size * sizeof(s16)) % 32;

  // Reservar memoria alineada: utilizamos memalign en lugar de malloc
  s16* sonido = (s16*)memalign(32, size * sizeof(s16) + relleno);

  // Realizar la lectura de datos desde el periferico
  // Utilizar char* como tipo de lectura es por compatibilidad
  // con libFat
  archivo.read((char*)sonido, size);

  // Fijar los datos leidos en la memoria, evita machacamiento
  // en la cache
  DCFlushRange(sonido, size * sizeof(s16) + relleno);
\end{lstlisting}

Como puede verse en el ejemplo, se calcula en primer lugar el relleno necesario para que la memoria que ocupa el archivo binario a cargar sea múltiplo de 32 bytes, a continuación se reserva la memoria alineada a 32 bytes utilizando la función \emph{memalign} en lugar de \emph{malloc}, y el último paso, tras leer la información desde el archivo, consiste en realizar el volcado explícito de información desde la caché de lectura a la memoria, utilizando la función \emph{DCFlushRange} (esta función recibe la dirección de memoria a la que se quiere realizar el volcado, y el tamaño de ésta).

\subsection{Depuración con \emph{LibWiiEsp}}

Con toda la información anterior descrita en este manual y la referencia completa de la biblioteca, se puede comenzar a desarrollar un videojuego sencillo. Como en todo proceso de desarrollo de software, ocurrirán errores, y aquí es donde se hace patente la falta de medios disponibles para depurar el código.\\

Existen dos tipos de errores que podremos encontrarnos a la hora de programar para Nintendo Wii, que corresponden con las fases de compilación y ejecución. A continuación, vamos a plantear cómo solucionar los posibles errores que pueden surgir en cada uno de estos momentos:

\subsubsection{Errores de compilación}

En la fase de compilación suelen ocurrir, sobretodo, errores de sintaxis, aunque también es posible que ocurran errores de enlazado si las rutas hasta los archivos de cabeceras o las bibliotecas de enlace estático no son correctas. El compilador nos avisará de cualquier tipo de error que ocurra, tanto en el preprocesado, como en la compilación propiamente dicha y en el enlazado. Así pues, prestando atención a los mensajes que pueda proporcionarnos el compilador sobre los errores o avisos que se den, podremos depurar el código fuente de nuestra aplicación.\\

Sobre los mensajes de enlazado, el enlazador nos proporcionará información suficiente para saber qué ha fallado durante esta operación, pero si se sigue al pie de la letra este manual (especialmente, la instalación del entorno y la creación del \emph{makefile}) no debería haber ningún problema.

\subsubsection{Errores de ejecución}

En la fase de ejecución es cuando tenemos verdaderos problemas para depurar nuestra aplicación, y es que apenas hay herramientas que puedan facilitarnos el conocer el estado de los objetos del sistema, el contenido de las variables, etc.\\

\emph{LibWiiEsp} proporciona un sistema de registro de eventos del sistema, la clase \emph{Logger}, que permite que escribamos un \emph{log} de errores, avisos e información variada. La forma de trabajar con esta clase es muy sencilla, y todos los detalles pueden consultarse en su documentación (ver referencia completa de la biblioteca). Pero hay ocasiones en que los errores en tiempo de ejecución requieren más precisión que una serie de mensajes que aportemos desde nuestro propio código, ya que el uso de la clase \emph{Logger} está recomendado en casos de comportamiento inesperado del programa, pero no de errores como tal.\\

\figura{excepcion.png}{scale=0.5}{Ejemplo de pantalla de error en tiempo de ejecución}{excepcion}{h}

Cuando ocurre un error de ejecución en la Nintendo Wii, ésta nos presentará una pantalla de error parecida a la imagen de la figura \ref{excepcion}. En esta pantalla de error pueden apreciarse tres partes principales. A la hora de localizar en qué parte de nuestro código se ha provocado este error, necesitamos fijarnos en la sección \emph{STACK DUMP}, es decir, la segunda. Esta parte del mensaje de error nos detalla la traza de llamadas a función que se han realizado hasta llegar a la llamada que ha producido el error, estando cada elemento de la traza representado por una dirección de memoria en hexadecimal.\\

Esta información es muy útil, ya que podemos localizar a qué línea de nuestro código fuente corresponde cada llamada con una utilidad incluida en \emph{DevKitPPC}, y esta es la utilidad \emph{powerpc-eabi-addr2line}. Se puede localizar en la carpeta \emph{/opt/devkitpro/devkitPPC/bin} si se ha seguido este manual para instalar \emph{LibWiiEsp}. Lo más cómodo es crear un enlace simbólico a esta utilidad en el directorio principal de nuestro proyecto, aunque también se puede añadir el directorio \emph{devkitPPC/bin} a la ruta donde el sistema busca ejecutables.\\

Siguiendo el ejemplo de la figura 1, si queremos saber a qué archivo y qué línea de código pertenece la dirección \emph{0x80011f54}, basta con ejecutar la siguiente línea de código en el directorio principal del proyecto:

\begin{lstlisting}[style=consola]
  ./powerpc-eabi-addr2line -e boot.elf -f 0x80011f54
\end{lstlisting}

Para que esta utilidad funcione, debemos tener en el directorio donde la ejecutamos una copia del ejecutable \emph{.elf} generado por nuestro proyecto (el mismo que hemos ejecutado en la consola y que nos ha dado el mensaje de error de la Figura 1). El parámetro \emph{-e} recibe el nombre de este ejecutable \emph{.elf}, y el parámetro \emph{-f} es la dirección de memoria (en hexadecimal) que ha producido el error.\\

Un ejemplo del resultado de la ejecución de la utilidad \emph{addr2line} puede ser el siguiente:

\begin{lstlisting}[style=consola]
  Actor
  /home/rabbit/Escritorio/libwiiesp/src/actor.cpp:27
\end{lstlisting}

Lo cual nos indica que el error se ha producido en la línea 27 del fichero fuente actor.cpp de \emph{LibWiiEsp}.\\

Un detalle a comentar es que, para salir de la pantalla de error que se muestra en la Figura 1, basta con pulsar el botón \emph{Reset} de la consola, lo que nos devolverá al \emph{Homebrew Channel}. \\

En resumen, con la herramienta \emph{addr2line} y la clase \emph{Logger} podemos ir realizando una decente depuración de nuestra aplicación, que aunque hay que reconocer que no es muy cómodo, es mejor que ir dando palos de ciego.

\section{Plantillas de \emph{LibWiiEsp}}

Con todo lo visto hasta el momento en este manual es posible comenzar el desarrollo de nuestra aplicación, ya que tenemos las herramientas preparadas, sabemos qué hay que tener en cuenta a la hora de utilizarlas, y además contamos con las clases de \emph{LibWiiEsp}, que nos facilitan (mucho) la vida a la hora de cargar recursos multimedia, establecer los idiomas del módulo de internacionalización, acceder a la tarjeta SD de la consola, dibujar texturas y animaciones en pantalla, etc.\\

Pero el punto más interesante de \emph{LibWiiEsp}, además de la abstracción que nos proporciona a la hora de trabajar con estos subsistemas de la videoconsola, está formado por las tres plantillas (clases abstractas) que ofrece para facilitar el desarrollo de un videojuego. Estas plantillas, que son \emph{Actor}, \emph{}Nivel y \emph{Juego}, permiten crear los distintos tipos de actores y niveles, además de la clase principal de nuestro programa, de una manera sencilla y efectiva.\\

Cabe destacar que, en el caso de que las plantillas ofrecidas no se adaptaran a las necesidades del videojuego que tenemos en mente, siempre podemos personalizar la clase que corresponda al derivarla, o bien modificando la clase original desde el código fuente de la biblioteca.\\

En esta sección del manual vamos a desgranar los detalles necesarios para poder sacar el máximo jugo a estas tres plantillas que nos facilitarán el desarrollo de nuestro videojuego:

\subsection{Sistemas de coordenadas}

En primer lugar, hay que comprender cómo funcionan los distintos sistemas de coordenadas que nos encontraremos a la hora de crear el universo de nuestro videojuego. La figura \ref{coordenadas} ilustra los tres sistemas que pueden darse a la vez en el juego.\\

\figura{coordenadas.png}{scale=0.6}{Distintos sistemas de coordenadas en el universo del juego}{coordenadas}{h}

La imagen al completo representa un escenario completo de un juego. Este escenario es el universo del juego en sí, tiene forma rectangular, y su esquina superior izquierda es el origen de coordenadas, siendo la X positiva hacia la derecha, y la Y hacia abajo. Todos las parejas de coordenadas, en cualquiera de los tres sistemas que se emplean, se refieren al punto superior izquierdo del objeto al que pertenecen las coordenadas. En la imagen, se distinguen las coordenadas relativas al escenario con el color amarillo.\\

El rectángulo verde que se aprecia en el centro de la imagen representa la parte del escenario que se muestra en la pantalla (actúa como si fuera una ventana desplazable). La pareja de coordenadas (x,y) en amarillo de este rectángulo indica la posición de desplazamiento de la pantalla, o \emph{scroll}, respecto al punto (0,0) del escenario. Jugando con el \emph{scroll} conseguimos que la pantalla \emph{se mueva} sobre el escenario, y muestre la parte que queramos de éste. Por otro lado, el vértice superior izquierdo de la pantalla es el origen de otro sistema de coordenadas, que indica la posición de un objeto (un actor, por ejemplo) dentro de la visualización en pantalla.\\

Teniendo en cuenta estos dos sistemas de coordenadas, se entiende fácilmente que el actor (el rectángulo rojo) tenga una pareja de coordenadas que indiquen su posición en el escenario (coordenadas en amarillo), y otra pareja de coordenadas (en verde) que denotan su posición en la pantalla. Sin embargo, las coordenadas de un actor respecto a la pantalla no se almacenan, si no que se calculan restando su posición en el escenario (amarillo) menos la posición del desplazamiento de la pantalla (coordenadas amarillas de la pantalla).\\

Además, el vértice superior izquierdo del rectángulo que representa al actor es el origen de un tercer sistema de coordenadas, que se utiliza como referencia para las cajas de colisión asociadas al actor.

\subsection{Actores}

Un actor es un objeto que tiene entidad propia dentro del universo del videojuego. En este sentido, son actores tanto los protagonistas manejados por los jugadores, como los enemigos controlados por la máquina, los \emph{items} que recogemos, cada una de las balas (en el caso de un juego de disparos) también es un actor\ldots \\

Entrando en el apartado técnico, un actor se representa como un objeto que tiene una pareja de coordenadas (x,y) respecto al origen del escenario, una velocidad en píxeles por fotograma (tanto vertical como horizontal), un conjunto de estados, cada uno de los cuales tiene asociada una animación y varias figuras de colisión, y un indicador sobre qué estado de los posibles es el actual.\\

A continuación se explican los diversos aspectos a tener en cuenta a la hora de crear un actor utilizando la clase abstracta que proporciona \emph{LibWiiEsp}. En primer lugar, tenemos que crear una clase derivada de \emph{Actor}. En el constructor de nuestra clase derivada, no debemos olvidar pasarle al constructor de \emph{Actor} la cadena de caracteres con la ruta absoluta hasta el archivo de datos desde el que se cargan los datos del actor, y una referencia al nivel en el que participará. Además, tenemos que definir el método \emph{actualizar}, que es un método virtual puro, y en el cual tenemos que definir el comportamiento del actor dependiendo de su estado actual.\\

Ambos aspectos se explican con detalle en los siguientes apartados:

\subsubsection{Cargando los datos de un actor}

Cada actor que se cree derivando la clase \emph{Actor} cargará toda la información relativa a él a través del método \emph{cargarDatosIniciales}, definido en la propia clase base \emph{Actor} (al cual se llama desde el constructor de ésta clase), y que recibe la ruta absoluta, en la tarjeta SD, de un archivo XML con un formato como el siguiente:\\

\begin{lstlisting}[style=XML]
<?xml version="1.0" encoding="UTF-8"?>
<actor vx="3" vy="3" tipo="jugador">
  <animaciones>
    <animacion estado="normal" img="chief" sec="0" filas="1" columnas="6" retardo="3" />
    <animacion estado="mover" img="chief" sec="0,1,2,3,4" filas="1" columnas="6" retardo="3" />
    <animacion estado="muerte" img="chief" sec="5" filas="1" columnas="6" retardo="0" />
  </animaciones>
  <colisiones>
    <rectangulo estado="normal" x1="27" y1="21" x2="55" y2="21" x3="55" y3="96" x4="27" y4="96" />
    <circulo estado="normal" cx="41" cy="13" radio="8" />
    <rectangulo estado="mover" x1="27" y1="21" x2="55" y2="21" x3="55" y3="96" x4="27" y4="96" />
    <circulo estado="mover" cx="41" cy="13" radio="8" />
    <sinfigura estado="muerte" />
  </colisiones>
</actor>
\end{lstlisting}

En el archivo XML anterior pueden observarse dos grandes bloques, uno para las animaciones y otro para las figuras de colisión. A cada estado (en el ejemplo hay tres, \emph{normal}, \emph{mover} y \emph{muerte}) le corresponde una única animación, pero puede tener ninguna, una o varias figuras de colisión. En el caso de que un estado concreto no tenga ninguna figura de colisión asociada, basta con introducir un nodo con el nombre \emph{sinfigura} y su correspondiente atributo \emph{estado}. Para más información sobre las animaciones o las figuras de colisión, consultar las secciones correspondientes en la referencia de la biblioteca.\\

\textbf{Muy importante}: Los estados en los cuales puede encontrarse un actor vienen definidos por los que aparezcan en este archivo de datos, y es \textbf{imprescindible} que definamos el estado \emph{normal} (al menos, en las animaciones), ya que es el estado que un actor toma por defecto, y si no se encontrara entre los datos del actor, se produciría un error en el sistema.\\

Para más información sobre la carga de datos iniciales, consultar la documentación de la clase Actor.

\subsubsection{Definir el comportamiento de un actor}

El comportamiento de un actor, como ya se ha comentado, depende del estado en el que se encuentre. A la hora de crear una clase derivada de \emph{Actor} se deberían implementar tantos métodos como estados se hayan definido en el archivo de datos del actor, de tal manera que cada uno de estos métodos corresponda con el comportamiento esperado en cada uno de los estados.\\

Por ejemplo, si tenemos un actor con tres estados (normal, caer y mover), tendríamos tres nuevos métodos llamados \emph{estado\_normal}, \emph{estado\_caer} y \emph{estado\_mover}. En cada una de estas funciones habría que implementar el comportamiento deseado de nuestro actor para ese estado concreto. En el siguiente código se muestra un ejemplo del método \emph{estado\_mover}, que se encargaría de desplazar horizontalmente al actor:

\begin{lstlisting}[style=C++]
void estado_mover(void) {
    mover(_x + _vx, _y);
}
\end{lstlisting}

Implementando de esta manera un método por cada estado, únicamente habría que definir el método virtual puro \emph{actualizar} para que, según el estado actual del actor, se ejecute la función correspondiente.\\

Lo ideal es organizar el comportamiento del actor en un autómata finito determinado, donde se especifiquen los estados posibles, y las transiciones que pueden darse entre los distintos estados. Hay que mencionar que los cambios de estado se realizarán desde una clase derivada de \emph{Nivel}, que será el escenario donde los actores se encontrarán. El motivo de esta decisión no es otro que la falta de conocimiento que tiene un actor sobre lo que ocurre a su alrededor en el escenario del juego, información que sí está disponible en todo momento en la clase que se encarga de gestionar éste.\\

\figura{automata.png}{scale=0.7}{Sencillo autómata de ejemplo para el comportamiento de un actor}{automata}{h}

En la figura \ref{automata} puede apreciarse un sencillo ejemplo de autómata finito determinado, formado por cuatro estados, y que define el comportamiento de un actor controlado por un jugador a través de un mando. El actor comienza en el estado denominado \emph{NORMAL}, en el que no sufre ninguna modificación de sus variables internas de posición. Desde este estado, y dependiendo de las condiciones que se cumplan, se puede pasar a los estados \emph{MOVER} (si el jugador pulsa el botón de movimiento) o \emph{CAER} (si no existe colisión entre el actor y el escenario). En el primero, nuestro actor modifica su posición horizontal en base a su velocidad en este eje, y en el segundo, se cambia la posición vertical hacia abajo, en base también a la velocidad del actor respecto al eje vertical. Desde estos dos estados puede llegarse a \emph{MOVER EN CAIDA}, que es una combinación de ambos (movimiento en ambos ejes).\\

Puede comprobarse que, en cada estado, se proporciona un comportamiento para el actor y una serie de condiciones para que sucedan cambios de estado del actor. La manera de comportarse del actor para cada estado debe programarse en el método \emph{actualizar} de la clase derivada de \emph{Actor} que controla a éste; sin embargo, las comprobaciones sobre el cumplimiento de condiciones que deben satisfacerse para ejecutar un cambio desde un estado a otro puede realizarse en el método correspondiente de la clase que controle el escenario (\emph{actualizarPj} para los actores jugadores, o \emph{actualizarNpj} en el caso de los actores controlados por la máquina), o bien en el propio método de actualización del actor, ya que éste tiene un atributo que es una referencia al nivel en el que participa. Se recomienda optar por la primera opción, para así separar el comportamiento del actor según el estado y las transiciones posibles entre éstos.

\subsection{Niveles}

Un nivel representa el escenario donde los actores, ya estén controlados por un jugador o por la máquina, interactúan entre sí y con los componentes de dicho nivel. Al igual que ocurre con los actores, \emph{LibWiiEsp} proporciona una clase base para crear niveles de una manera sencilla y rápida, que permite diseñar cada nuevo escenario utilizando el software \emph{Tiled}, editor de mapas de \emph{tiles}.\\

Hay que distinguir entre los conceptos de escenario y nivel. Para \emph{LibWiiEsp}, un nivel es una clase derivada de la clase abstracta \emph{Nivel}, y que define varios escenarios que se comportan de la misma forma, siendo cada escenario un mapa de lites generado con \emph{Tiled} en el que se especifica la disposición de los \emph{tiles} y los actores que participan.\\

Con esto se consiguen varias ventajas. En primer lugar, definiendo una sola vez el comportamiento de un tipo de escenario en una clase derivada de \emph{Nivel}, se pueden generar múltiples escenarios cuya lógica sea la implementada en esta clase. Por otro lado, este sistema permite que, en un mismo videojuego, se puedan intercalar fácilmente escenarios con comportamientos distintos (como ejemplo, se puede pensar en las típicas fases de \emph{bonus} de clásicos como \emph{Street Fighter}, en las que se debe destruir un coche o varios barriles en lugar de luchar contra otro oponente controlado por la máquina).

\subsubsection{Partes de un nivel}

Un nivel se compone de tres partes, que son los distintos tipos de objetos que se cargan en un escenario. En primer lugar, se encuentran las \emph{propiedades} del nivel, que son una serie de cadenas de caracteres que indican códigos de recursos en la galería de medias del sistema; las propiedades del nivel son la imagen de fondo (que es fija, y permite dibujar un paisaje estático en la última capa de dibujo), la pista de música asociada a un nivel y la imagen del \emph{tileset}. Pueden añadirse más propiedades según el videojuego que estemos desarrollando, pero la lectura y carga de esta información deberá ser programada en el constructor de la clase derivada. Las partes básicas del escenario se pueden apreciar en la figura \ref{partesescenario}.\\

\figura{partesescenario.png}{scale=0.5}{Distintas partes de un escenario}{partesescenario}{h}

Llegados a este punto, es necesario explicar brevemente los conceptos de \emph{tile} y \emph{tileset}. Un \emph{tile} es una imagen pequeña, generalmente cuadrada o rectangular, que se utiliza para componer un escenario en un videojuego en dos dimensiones. En un mismo escenario, se emplean numerosos \emph{tiles} que se recogen en una única imagen organizados como una tabla (es decir, en filas y columnas). Esta imagen que almacena todos los \emph{tiles} utilizados en un mismo escenario es lo que conocemos por \emph{tileset}. En la figura \ref{tileset} hay un ejemplo de un \emph{tileset} con el que se podría dibujar un escenario para un juego de vista cenital.\\

\figura{tileset.png}{scale=1}{Ejemplo de \emph{tileset}, formado por 6 \emph{tiles} de 32x32 píxeles}{tileset}{h}

Continuando con los tipos de objeto que componen un escenario, en segundo lugar tenemos la propia composición de éste, que está formada por dos capas de dibujo en las que se define la composición del escenario en sí a partir de los \emph{tiles} del \emph{tileset} asociado al nivel. Internamente, cada capa de dibujo se divide en una rejilla de cuadros (filas y columnas), donde cada celda tiene las mismas dimensiones que un \emph{tile}, y en ella se coloca un \emph{tile} concreto. Una de las dos capas del escenario, la llamada \emph{PLATAFORMAS}, se caracteriza en que, cuando \emph{LibWiiEsp} la carga en memoria, asigna a cada \emph{tile} una figura de colisión de su mismo tamaño, de tal manera que los \emph{tiles} que componen esta capa de dibujo pueden interactuar con los actores del juego. Por otro lado, la capa denominada \emph{ESCENARIO} está compuesta por \emph{tiles} que no tienen asociada ninguna figura de colisión, y únicamente se añaden al nivel con el objetivo de mejorar visualmente el escenario.\\

Generalmente, esta distinción entre \emph{tiles} con figura de colisión asociada y sin ella se utiliza para definir los \emph{tiles} que pueden ser atravesados por los actores del juego (aquellos que no tienen asociada una figura de colisión), y los que no permiten que los actores los atraviesen, que son los que sí tienen figura de colisión asociada. Puede verse un ejemplo en la figura \ref{ejemplotiles}.\\

\figura{ejemplotiles.png}{scale=0.8}{Ejemplo de escenario con \emph{tiles} atravesables y no atravesables}{ejemplotiles}{h}

Por último, nos encontramos con el último tipo de objetos que necesitamos para definir un escenario, que son los actores que participan en el nivel. Se distinguen los actores controlados por los jugadores, y los que son dirigidos por la máquina.\\

Como ya se ha comentado en la sección de los actores, éstos tendrán definido su comportamiento según el estado en el que se encuentren en un momento determinado. Sin embargo, las transiciones entre distintos estados es conveniente realizarlas en el correspondiente método de actualización de la clase que gestiona el escenario, a pesar de que se pueden hacer desde la clase del actor.

\subsubsection{Creación de un escenario con \emph{Tiled}}

El proceso de creación de un escenario a partir de la herramienta \emph{Tiled} \cite{website:tiled} es muy sencillo. En su página oficial podemos descargar la última versión o, dependiendo de si el sistema en el que nos encontremos (en mi caso al redactar este manual, una Ubuntu 10.10) dispone de esta utilidad en los repositorios, se puede instalar con la siguiente orden:

\begin{lstlisting}[style=consola]
sudo apt-get install tiled
\end{lstlisting}

Una vez instalado, ejecutamos \emph{Tiled} y pulsamos en el botón \emph{Nuevo}. Se abrirá una ventana en la que se nos preguntan algunos parámetros del nuevo mapa de \emph{tiles}. Seleccionamos proyección ortogonal, el ancho y alto en píxeles de cada \emph{tile}, y el ancho y alto medido en número de \emph{tiles} que tendrá el escenario. Las medidas de un \emph{tile} deben ser múltiplos de 8 píxeles, debido a los requisitos para la carga de texturas con \emph{LibWiiEsp}, siendo un tamaño recomendable es 32x32 píxeles por \emph{tile}. La resolución que utiliza la Nintendo Wii en un sistema PAL y proporción 4:3 es de 640 píxeles de ancho por 528 de alto, por lo que el tamaño mínimo del escenario debería ser (si utilizamos la medida 32x32 píxeles por \emph{tile}) de 20 \emph{tiles} de ancho, por 16 \emph{tiles} de alto. Una vez establecidos estos parámetros, pulsamos en aceptar.\\

A continuación, hay que cargar en la herramienta la imagen que contiene el \emph{tileset}. Para ello, pulsamos en \emph{Mapa}, y después en \emph{Nuevo conjunto de patrones}. Se abrirá un diálogo en el que debemos introducir el nombre que le daremos a la imagen (esto es un dato interno de \emph{Tiled}, y el valor introducido aquí no es relevante), la propia imagen, y las medidas que tendrá un \emph{tile} (ancho y alto en píxeles). Un detalle a tener en cuenta, en nuestra imagen no debe haber separación entre los \emph{tiles}, ni tampoco margen. Al introducir estos datos, hacemos clic en \emph{Aceptar} y ya tendremos el \emph{tileset} listo para dibujar el mapa.\\

Como siguiente punto, hay que introducir las tres propiedades del escenario. Nos vamos a \emph{Mapa} y entonces a \emph{Propiedades del Mapa}, e introducimos en la lista estas propiedades:

\begin{itemize}
\item imagen\_fondo: Su valor es el código que tendrá la imagen de fondo del escenario en la galería de recursos del sistema.
\item imagen\_\emph{tileset}: Su valor es el código que tendrá la imagen del \emph{tileset} del escenario en la galería de recursos del sistema.
\item musica: Su valor es el código que tendrá la pista de música del escenario en la galería de recursos del sistema.
\end{itemize}

Tras introducir las propiedades, pulsamos en \emph{Aceptar}, y procedemos a preparar las tres capas de dibujo de nuestro escenario, que deben llamarse obligatoriamente como se describe en la lista:

\begin{itemize}
\item escenario: Capa de patrones donde dibujaremos los \emph{tiles} atravesables.
\item plataformas: Capa de patrones donde dibujaremos los \emph{tiles} no atravesables, es decir, los que tendrán asociada una figura de colisión.
\item actores: Capa de objetos donde situaremos todos los actores que participen en el nivel.
\end{itemize}

En este punto, ya estamos en disposición de comenzar a dibujar nuestro escenario. Es recomendable comenzar por la capa de \emph{tiles} no atravesables, continuar decorando con los \emph{tiles} atravesables, y por último, establecer la posición de los actores. Para situar un actor en el escenario, insertamos un objeto en el lugar que deseemos, y lo redimensionamos adecuadamente para que se vea correctamente cómo quedaría su posición inicial. Seguidamente, hacemos clic con el botón derecho en el actor, y pulsamos en \emph{Propiedades del objeto}. Se mostrará un diálogo en el que debemos indicar, en el campo \emph{Tipo}, el tipo del actor que comenzará aquí (dato necesario a la hora de distinguir qué clase derivada de \emph{Actor} hay que instanciar), y además la propiedad \emph{xml}, cuyo valor debe ser la ruta absoluta hasta el archivo XML que contiene la información de este tipo de actor en la tarjeta SD de la Nintendo Wii. Además, si el actor es controlado por un jugador, debemos añadir también la propiedad \emph{jugador} con el código identificativo del jugador que jugará con este actor como valor.\\

A la hora de definir los distintos actores, se puede utilizar el campo \emph{Nombre} del diálogo de propiedades de un actor para identificarlo en tiempo de diseño del escenario.

\subsubsection{Implementando una clase que controle escenarios}

Una vez tenemos creados uno o varios escenarios cuyo comportamiento (la gestión de transiciones entre los estados de los distintos actores que participan en él, el movimiento o no del \emph{scroll} de la pantalla sobre el escenario, etc.) es común, el último paso para poder disfrutar de ellos es definir una clase derivada de la abstracta \emph{Nivel} que controle todos los detalles del nivel. Cada clase derivada definirá una gestión distinta de un grupo de varios escenarios.\\

El primer paso para crear una clase derivada de la abstracta \emph{Nivel} es implementar el método virtual \emph{cargarActores}. Como se detalla en la documentación de la clase, en el constructor se cargan todos los \emph{tiles} del escenario, se toma la imagen de fondo y del \emph{tileset} desde la galería, y se leen los datos de inicialización de cada actor participante, almacenándose en una estructura temporal. La definición de este método debe recorrer esta estructura temporal de datos de actores, creando, para cada ocurrencia, un actor de la clase derivada de \emph{Actor} correspondiente, tal y como se aprecia en el siguiente ejemplo:

\begin{lstlisting}[style=C++]
void cargarActores(void) {
  for(Temporal::iterator i = _temporal.begin(); i != _temporal.end(); ++i)
  {
    if(i->tipo_actor == "jugador") {
      Personaje* p = new Personaje(i->xml, this);
      p->mover(i->x, i->y);
      _jugadores.insert(std::make_pair(i->jugador, p));
    } else if(i->tipo_actor == "bicho") {
      Bicho* p = new Bicho(i->xml, this);
      p->mover(i->x, i->y);
      _actores.push_back(p);
    }
  }
  _temporal.clear();
};
\end{lstlisting}

En el ejemplo, el programador ha definido dos clases derivadas de \emph{Actor}, denominadas \emph{Personaje} y \emph{Bicho}. En el método implementado, se recorre la estructura temporal de datos de actores del escenario, y se crea un actor a partir de la clase correspondiente (según el tipo de actor que se haya indicado desde \emph{Tiled}), se mueve el actor hasta su posición en el escenario, y por último se inserta en la estructura adecuada (\emph{\_jugadores} en el caso de los actores controlados por un jugador, en la que hay que indicar también el código identificador del jugador concreto; o \emph{\_actores} para los actores controlados por la máquina).\\

Es importante recordar que este método \emph{cargarActores} se debe llamar desde el constructor de la clase derivada de \emph{Nivel} con la intención de que la creación de los actores se realice en el momento de cargar el escenario. Además, es recomendable vaciar la estructura temporal cuando se finalice el proceso.\\

El siguiente paso en la generación de esta clase derivada es implementar los métodos de actualización del nivel, que se deberían llamar en cada fotograma del programa. A continuación se indican cuáles son, y qué funcionalidad se espera que tengan.\\

En el método \emph{actualizarPj} se debe actualizar el estado de un único actor jugador, atendiendo tanto al mando concreto que tenga asociado en la estructura \emph{\_jugadores}, como a la situación del escenario. Un ejemplo sencillo podría ser:

\begin{lstlisting}[style=C++]
void actualizarPj(const std::string& jugador, const Mando& m) {

  // Estado NORMAL: puede pasar a MOVER
  if(_jugadores[jugador]->estado() == "normal") {
    if(m.pressed(Mando::BOTON_ARRIBA) or m.pressed(Mando::BOTON_ABAJO))
      _jugadores[jugador]->setEstado("mover");
  }

  // Estado MOVER: puede pasar a NORMAL
  if(_jugadores[jugador]->estado() == "mover") {
    if(m.pressed(Mando::BOTON_ARRIBA)) {
      _jugadores[jugador]->invertirDibujo(true);
      s16 vel_x = _jugadores[jugador]->velX();
      if(vel_x > 0)
        vel_x *= -1;
      _jugadores[jugador]->setVelX(vel_x);
    } else if(m.pressed(Mando::BOTON_ABAJO)) {
      _jugadores[jugador]->invertirDibujo(false);
      s16 vel_x = _jugadores[jugador]->velX();
      if(vel_x < 0)
        vel_x *= -1;
      _jugadores[jugador]->setVelX(vel_x);
    } else
      _jugadores[jugador]->setEstado("normal");
  }

  // Actualizar el actor en base a su nuevo estado actual
  _jugadores[jugador]->actualizar();
}
\end{lstlisting}

Por otro lado, el método \emph{actualizarNpj} debe recorrer la estructura en la que se almacenan los actores controlados por la máquina y actualizar los que se consideren oportunos (aquí se deja en manos del programador el actualizar todos los actores, sólo los que están en pantalla, o los que cumplan un determinado criterio). Como ejemplo, se muestra la siguiente función que actualizaría el estado de todos los actores no jugadores:

\begin{lstlisting}[style=C++]
void actualizarNpj(void) {
  for(Actores::iterator i = _actores.begin() ; i != _actores.end() ; ++i) {
    // Estado NORMAL: puede pasar a CAER
    if((*i)->estado() == "normal")
      if(not colision((*i)))
        (*i)->setEstado("caer");

    // Estado CAER: puede pasar a NORMAL
    if((*i)->estado() == "caer")
      if(colisionVertical((*i)))
        (*i)->setEstado("normal");

    // Actualizacion del actor
    (*i)->actualizar();
  }
};
\end{lstlisting}

El último método a implementar es \emph{actualizarEscenario}, en el que se espera que se implementen todos los demás detalles relativos al escenario que necesiten ser actualizados a cada fotograma del juego. El siguiente ejemplo muestra una implementación que únicamente actualiza el \emph{scroll} de la pantalla sobre el escenario, según la posición horizontal del jugador cuyo código identificador es \emph{pj1}:

\begin{lstlisting}[style=C++]
void actualizarEscenario(void) {

  if(_jugadores["pj1"]->x() - _scroll_x >= screen->ancho() / 2)
    moverScroll(_scroll_x + abs(_jugadores["pj1"]->velX()), _scroll_y);
  else if(_jugadores["pj1"]->x() - _scroll_x <= screen->ancho() / 4)
    moverScroll(_scroll_x - abs(_jugadores["pj1"]->velX()), _scroll_y);

  if(_jugadores["pj1"]->y() - _scroll_y >= screen->alto() / 2)
    moverScroll(_scroll_x, _scroll_y + abs(_jugadores["pj1"]->velY()));
  else if(_jugadores["pj1"]->y() - _scroll_y <= screen->alto() / 4)
    moverScroll(_scroll_x, _scroll_y - abs(_jugadores["pj1"]->velY()));
};
\end{lstlisting}

Por supuesto, quiero remarcar que los métodos de ejemplo son precisamente eso, ejemplos muy sencillos cuya finalidad es que sirvan de guía para comprender cómo se trabaja con la plantilla de niveles de \emph{LibWiiEsp}, y a partir de los cuales poder desarrollar los métodos de actualización necesarios (al derivar la clase abstracta \emph{Nivel} se pueden añadir los métodos que se consideren necesarios).

\subsection{Juego}

La clase abstracta \emph{Juego} es la tercera y última plantilla que \emph{LibWiiEsp} ofrece para facilitar el desarrollo de videojuegos para Nintendo Wii. Es muy sencilla, y consiste en dos partes principales. El constructor se encarga de inicializar la consola a partir de la información que se introduzca en el archivo de configuración de la aplicación, y el método \emph{run} ejecuta el bucle principal del programa. A continuación se aportan todos los detalles relativos a esta plantilla para construir la clase principal de nuestro videojuego.

\subsubsection{Inicialización de la consola}

Como ya se ha comentado, la inicialización de todos los sistemas de la consola Nintendo Wii se realiza en el constructor de la clase \emph{Juego}, que recibe como parámetro la ruta absoluta en la tarjeta SD de un archivo XML de configuración. Esta inicialización consiste en montar la primera partición de la tarjeta SD de la consola (debe tener un sistema de ficheros FAT), establecer el sistema de \emph{logging}, leer el archivo de configuración y, a partir de éste, iniciar todos los aspectos de la consola que vamos a utilizar.\\

El proceso de inicialización, llegados a este punto, es el siguiente:

\begin{enumerate}
\item Inicializar la pantalla, el sistema de mandos, el sonido y las fuentes de textos (en este orden).
\item Establecer el color transparente, y los fotogramas por segundo que tendrá la aplicación.
\item Cargar los identificadores de los jugadores y asociar un mando con cada uno de ellos.
\item Cargar en memoria todos los recursos multimedia que se indiquen en el archivo XML de la galería.
\item Cargar en memoria las etiquetas de texto del soporte de internacionalización.
\end{enumerate}

Cuando creamos una clase derivada de \emph{Juego} hay que llamar al constructor de la clase base, pasándole como parámetro la ruta absoluta en la tarjeta SD del archivo de configuración. Por otro lado, el destructor de la clase base se encarga de liberar la memoria ocupada por la estructura que almacena los objetos de la clase \emph{Mando}, y de llamar a la función \emph{exit}, hecho obligatorio para que la pila de la función \emph{atexit} se ejecute al salir del programa (esto es muy importante, ya que en caso contrario nos encontraremos con una pantalla de error por no haber apagado los sistemas de la consola).\\

Un ejemplo del archivo XML de configuración es el siguiente:

\begin{lstlisting}[style=XML]
<?xml version="1.0" encoding="UTF-8"?>
<conf>
  <log valor="/apps/wiipang/info.log" nivel="3" />
  <alpha valor="0xFF00FFFF" />
  <fps valor="25" />
  <galeria valor="/apps/wiipang/xml/galeria.xml" />
  <lang valor="/apps/wiipang/xml/lang.xml" defecto="english" />
  <jugadores pj1="pj1" pj2="pj2" pj3="" pj4="" />
</conf>
\end{lstlisting}

En este archivo de configuración se establece que el sistema de \emph{logging} registrará todos los eventos que sucedan en el sistema, el color transparente será el magenta, se correrá la aplicación a 25 fotogramas por segundo, se indican los archivos XML de la galería y el sistema de internacionalización, se establece el inglés como idioma por defecto, y se prepara la consola para trabajar con dos mandos, asociados respectivamente a un jugador identificado por el código \emph{pj1} y otro identificado por \emph{pj2}.

\subsubsection{El bucle principal}

La clase base \emph{Juego} proporciona, además, un método que ejecuta un bucle principal sencillo. Este método es virtual, de tal manera que si el programador necesita otra forma de gestionar su aplicación, se le permite redefinirlo en su clase derivada.\\

El método \emph{run} es el que se encarga de controlar este bucle principal. En primer lugar, llama al método \emph{cargar}, que es virtual puro y debe ser definido en la clase derivada de \emph{Juego}. En esta función debe ejecutarse todo lo que se necesite \textbf{antes} de que se entre en el bucle. Después, se inicializa la bandera de salida con un valor falso y se establece el contador de ciclos del procesador a cero (este contador se utiliza para mantener constante el valor de los fotogramas por segundo), tras lo cual se entra en el bucle principal.\\

El bucle principal actualiza, al principio de cada fotograma, el estado de todos los mandos conectados a la consola, ejecuta el método virtual puro \emph{frame}, y después finaliza el fotograma y controla la tasa de FPS. En este método \emph{frame} se incluirán todos los detalles de la ejecución de cada fotograma, y devolverá un valor booleano falso si la ejecución debe continuar, siendo el valor de retorno verdadero en el caso de que el programa deba terminar.\\

Un detalle más, en el caso de que ocurriera una excepción en el transcurso de la ejecución del programa, ésta será registrada por el sistema de \emph{logging} (siempre que éste esté activado, al menos, en el nivel \emph{error}, identificador 1), y después se saldrá de la aplicación.\\

Por último, destacar el hecho de que tanto si se necesita una gestión del bucle principal diferente, o un mayor número de funciones, el hecho de tener que derivar de la clase \emph{Juego} implica la posibilidad de crear tantos métodos como sea necesario, y la redefinición opcional del método \emph{run} nos permite ejecutar estos nuevos métodos de la manera que mejor se adecúe a nuestras necesidades.

